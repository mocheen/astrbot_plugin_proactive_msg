# AstrBot主动消息插件业务逻辑文档

## 1. 项目背景

### 1.1 AstrBot项目概述

AstrBot是一个开源的一站式Agent聊天机器人平台及开发框架，具有以下主要特点：

- **多平台支持**：支持接入QQ、企业微信、微信公众号、飞书、Telegram、钉钉、Discord、KOOK等多种消息平台
- **大模型对话**：支持接入多种大模型服务，包括OpenAI、Anthropic、Google Gemini、Moonshot AI等
- **Agent能力**：完善适配的Agentic能力，支持多轮工具调用、内置沙盒代码执行器、网页搜索等功能
- **插件扩展**：深度优化的插件机制，支持开发插件扩展功能，社区插件生态丰富
- **WebUI管理**：提供可视化配置和管理机器人界面

### 1.2 AstrBot技术架构

AstrBot基于Python 3.10+开发，采用现代化的架构设计：

- **核心框架**：基于异步编程模型，使用aiohttp、asyncio等库实现高并发处理
- **插件系统**：通过Star类实现插件基类，所有插件继承此类并实现特定功能
- **配置管理**：使用JSON格式存储配置，支持动态配置更新
- **数据库支持**：集成SQLAlchemy和SQLite，提供数据持久化能力
- **调度系统**：集成APScheduler，支持定时任务和事件调度

### 1.3 插件开发环境

AstrBot插件开发遵循以下规范：

- **继承结构**：所有插件必须继承自 `astrbot.core.star.Star`基类
- **生命周期**：实现 `initialize()`和 `terminate()`方法处理插件生命周期
- **配置管理**：通过JSON文件管理插件配置
- **WebUI集成**：支持通过WebUI界面配置插件参数和状态
- **日志记录**：使用AstrBot统一的日志系统记录插件运行状态
- 备注：如果有不清楚的规范，请先去AstrBot\data\plugins\astrbot_plugin_meme_manager这个示例插件中确认，千万不要直接自己进行。

## 2. 插件概述

### 2.1 插件名称

astrbot_plugin_proactive_msg

### 2.2 插件功能

本插件旨在为AstrBot添加智能主动消息功能，使机器人能够根据上下文和历史对话，主动发起有意义的对话，而不是仅仅被动回复。插件将利用大模型的分析能力，判断何时应该主动发起对话，以及应该发送什么内容。

### 2.3 插件目标

- 提高机器人交互的自然性和主动性
- 增强用户体验，使机器人更像一个真实的对话伙伴
- 通过模型分析，避免不必要的打扰，只在合适时机发起对话
- 提供灵活的配置选项，适应不同用户的需求和场景

## 3. 核心功能

### 3.1 时间感知配置检查

- 在插件启动时检查astrbot本体的 `datetime_system_prompt` 配置是否开启
- 这个配置会让上下文中携带当时的时间信息，有助于我们的agent的判断工作
- 如果未开启，记录警告日志但不影响插件启动
- 日志内容：`"警告：datetime_system_prompt配置未开启，主动消息插件可能无法获取准确时间"`

### 3.2 定时任务功能

- 使用 AsyncIOScheduler 实现定时任务
- 支持用户自定义轮询间隔，提供以下选项：
  - 5分钟
  - 10分钟（默认）
  - 半小时
  - 1小时
  - 3小时
- 每次轮询时检查是否需要发送主动消息

### 3.3 消息历史获取和分析

- 与 AstrBot 本体保持一致的消息历史获取方式
- 支持私聊场景的消息历史分析
- 通过程序判断最近一段时间内是否有历史消息
- 如果无消息时间阈值内有历史消息，则跳过本次轮询，不调用模型
- 无消息时间阈值可通过 WebUI 自定义，提供以下选项：
  - 1分钟
  - 5分钟（默认）
  - 10分钟
  - 半小时
  - 1小时

### 3.4 LLM 工具调用

- 确认无消息时间阈值内无历史消息后，调用 LLM 判断是否需要发送主动消息
- 将消息历史上下文传递给 LLM
- LLM 根据上下文中的时间判断是否现在发送主动消息是否合适
- 合适则让 LLM 在回复中带上标识“^&YES&^”，并且根据上下文生成合适的话题。
- 不合适则让 LLM 直接回复“^&NO&^”
- 仅考虑私聊场景

### 3.5 主机器人调用

- 当检查到LLM的回复中包含“^&YES&^”时，截取LLM输出的话题信息
- 调用主机器人，发送以下内容：“你好，我不是用户，我是另一个ai。我来负责提醒你给用户发送主动消息，你不需要让用户知道我的存在。现在是发送消息的合适时间，话题是{{LLM生成的话题}}。请生成合适的内容发送。”
#### 如何调用主机器人发送消息

   通过平台适配器的 send_by_session 方法 ：
   
   - 每个平台适配器都实现了 send_by_session(session, message_chain) 方法
   - 需要提供 MessageSession 对象和 MessageChain 对象
### 3.6 用户友好的配置选项

- WebUI 不显示此 agent 的具体 prompt 信息
- 提供用户友好的轮询时间间隔选项
- 提供用户友好的回复频率选项
- 通过预设模式动态修改 prompt 占位符内容

## 4. 配置管理

### 4.1 配置存储方式

- 参考 astrbot_plugin_meme_manager，使用 JSON 格式存储配置
- 配置文件路径：`data/config/proactive_msg_config.json`
- 使用 `_conf_schema.json` 定义配置模式

### 4.2 配置项设计

```json
{
  "poll_interval": {
    "description": "轮询间隔",
    "type": "string",
    "default": "10min",
    "options": ["5min", "10min", "30min", "1hour", "3hour"]
  },
  "no_message_threshold": {
    "description": "无消息时间阈值",
    "type": "string",
    "default": "30min",
    "options": ["1min", "5min", "10min", "30min", "1hour"]
  },
  "reply_frequency": {
    "description": "回复频率模式",
    "type": "string",
    "default": "moderate",
    "options": ["rare", "moderate", "frequent"]
  },
  "enable_time_check": {
    "description": "启用时间感知检查",
    "type": "bool",
    "default": true
  }
}
```

### 4.3 预设模式设计

- **rare（稀少）**：减少主动消息频率，适用于不希望打扰用户的场景
- **moderate（适中）**：平衡的主动消息频率，适用于一般场景
- **frequent（频繁）**：增加主动消息频率，适用于需要高互动的场景

## 5. 技术实现

### 5.1 插件结构

```
astrbot_plugin_proactive_msg/
├── main.py              # 主插件文件
├── metadata.yaml        # 插件元数据
├── _conf_schema.json    # 配置模式定义
├── config.py           # 配置管理
├── scheduler.py        # 定时任务管理
├── message_analyzer.py # 消息分析器
└── prompt_manager.py   # 提示词管理器
```

### 5.2 关键类和方法

#### 5.2.1 主插件类 (ProactiveMsg)

```python
@register("proactive_msg", "主动消息插件", "使 bot 在用户长时间未发送消息时主动与用户对话", "1.0")
class ProactiveMsg(Star):
    def __init__(self, context: Context, config: dict = None):
        # 初始化插件
        # 检查时间感知配置
        # 初始化定时任务调度器
        # 初始化消息分析器
        # 初始化提示词管理器
  
    async def initialize(self):
        # 启动定时任务
  
    async def terminate(self):
        # 停止定时任务
```

#### 5.2.2 定时任务管理器 (SchedulerManager)

```python
class SchedulerManager:
    def __init__(self, context: Context, config: dict):
        # 初始化 AsyncIOScheduler
        # 设置时区
  
    def start(self):
        # 启动调度器
  
    def stop(self):
        # 停止调度器
  
    def add_job(self, func, interval):
        # 添加定时任务
```

#### 5.2.3 消息分析器 (MessageAnalyzer)

```python
class MessageAnalyzer:
    def __init__(self, context: Context, config: dict):
        # 初始化消息分析器
  
    async def should_send_proactive_message(self, session_id: str) -> bool:
        # 检查最近是否有消息
        # 获取消息历史
        # 调用 LLM 判断是否需要发送主动消息
        # 返回是否需要发送主动消息
```

#### 5.2.4 静态prompt文件

- 让 LLM 理解自己的工作内容
- 让 LLM 知道如何该如何输出，让程序可以正确识别是否要发消息以及话题内容。
- 活跃程度用占位符表示，从配置中读取，添加合适的提示词如“平均XX分钟回复，但偶尔可以例外”，让 LLM 明白用户需要回复频繁一些还是安静一些。

#### 5.2.5 提示词管理器 (PromptManager)

```python
class PromptManager:
    def __init__(self, config: dict):
        # 初始化提示词管理器
  
    def get_prompt(self, frequency_mode: str) -> str:
        # 根据频率模式获取提示词
        # 替换占位符内容
```

### 5.3 关键流程

#### 5.3.1 插件初始化流程

1. 检查 `datetime_system_prompt` 配置是否开启
2. 加载插件配置
3. 初始化定时任务调度器
4. 初始化消息分析器
5. 初始化提示词管理器
6. 启动定时任务

#### 5.3.2 定时任务执行流程

1. 获取所有私聊会话
    #### 如何获取所有私聊会话
   1.
      通过数据库获取会话列表 ：
   
      - 使用 conversation_mgr.py 中的 ConversationManager 类
      - 调用 get_conversations() 方法可以获取所有对话列表
      - 通过 unified_msg_origin 参数可以过滤特定平台的会话
   2.
      通过平台适配器获取私聊会话 ：
   
      - 每个平台适配器都有自己的方式获取私聊会话
      - 例如，QQ平台可以通过 get_friend_list() API获取好友列表
      - 微信平台可以通过 get_contact_details_list() 获取联系人列表
   3.
      识别私聊会话 ：
   
      - 使用 AstrMessageEvent.is_private_chat() 方法判断是否为私聊
      - 或者检查 message_obj.type == MessageType.FRIEND_MESSAGE
      - 
2. 对每个会话执行以下操作：
   - 检查最近是否有消息（根据无消息时间阈值）
   - 如果最近有消息，跳过本次检查
   - 如果最近无消息，调用消息分析器判断是否需要发送主动消息
   - 如果需要发送，生成并发送主动消息

#### 5.3.3 消息分析流程

1. 获取会话的消息历史
2. 构建提示词（根据回复频率模式）
3. 调用 LLM 判断是否需要发送主动消息
4. 返回判断结果

## 6. WebUI 集成

### 6.1 配置界面设计

- 轮询间隔选择器
- 无消息时间阈值选择器
- 回复频率模式选择器
- 时间感知检查开关

## 7. 错误处理和日志

### 7.1 错误处理

- 定时任务执行失败处理
- LLM 调用失败处理
- 消息发送失败处理

### 7.2 日志记录

- 插件启动/停止日志
- 定时任务执行日志
- 每次调用 LLM 时 LLM 的输出内容
- 主动消息发送日志
- 错误日志

## 8. 扩展性考虑

### 8.1 配置扩展性

- 预留配置项，方便未来扩展
- 使用 JSON 格式存储配置，便于修改和扩展
